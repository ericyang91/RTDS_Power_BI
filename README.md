# Road to Data Science: Power BI
## Data Preparation

**To make Excel or CSV data Power BI compatible, your goal is to structure it in a clean, tabular, and relational-friendly format that Power BI can easily interpret and transform into visuals.**

---

**1. Structure your data in a tabular format**
- Each sheet (in Excel) or file (CSV) should resemble a table in a database.
- Each row should represent a single record or transaction.
- Each column should represent one variable or attribute.
- Power BI will easily recognize the "Good" table. It will struggle to understand the "Bad" one ‚Äî especially if headers are spread across multiple rows/columns.

| Good Format               | Bad Format                      |
| ------------------------ | ------------------------------ |
| Column headers in row 1   | Column headers in row 3         |
| No merged cells           | Merged cells across months      |
| Each row = 1 data entry   | Headers split across rows/cols  |

---

‚úÖ Example (Good Format)

| Date       | Product | Quantity | Price |
|------------|---------|----------|-------|
| 2025-06-01 | Apples  | 10       | 0.50  |

---

‚ùå Example (Bad Format ‚Äì Merged header or missing labels)

|          | Apples | Oranges |
|----------|--------|---------|
| Quantity | 10     | 12      |
| Price    | 0.50   | 0.80    |

---

**2. Use proper headers**
- Headers = Column names, and they must:
  - Be in row 1 (no intro rows like ‚ÄúSales Report Q2‚Äù above it).
  - Have no duplicates.
  - Use simple, descriptive names like ProductName, not Column1.
  - Power BI reads the first row as headers. If the first row contains actual data, you‚Äôll have to fix it manually during import (Power Query ‚Üí ‚ÄúUse First Row as Headers‚Äù).

---

**3. Avoid pivoted/crosstab layouts**
- Power BI prefers long format, not wide format.
- Why?
  - Visuals like bar charts and filters work better with vertical data.
  - You can use ```UNPIVOT``` in Power Query if needed.

---

‚ùå Pivoted Format (Not Ideal for Power BI)

| Region | Jan | Feb | Mar |
|--------|-----|-----|-----|
| West   | 100 | 200 | 150 |

---

‚úÖ Unpivoted Format (Tidy / Power BI Friendly)

| Region | Month | Sales |
|--------|--------|-------|
| West   | Jan    | 100   |
| West   | Feb    | 200   |
| West   | Mar    | 150   |

- Power BI can now group by Region, filter by Month, and aggregate Sales.

---

**4. Use separate tables for each entity**
- Example setup for a sales dashboard:
  - ```Sales:``` Transactional table
  - ```Customers:``` Info on customers
  - ```Products:``` Product info (name, category, etc.)
  - ```Calendar:``` All dates
 - Each table should have:
  - A **primary key** (like ProductID).
  - Clean, distinct columns (no overlapping names unless it‚Äôs a key for a relationship).
  - Use **Model View in Power BI** to connect them (one-to-many relationships).

---

**5. Ensure clean data**
- Why this matters: Power BI auto-detects data types. Mixed types can break visuals or calculations.
- Watch out for:
  - Columns with numbers and text (12, 15, --N/A--).
  - Dates in wrong format (e.g., text "01/2024" instead of date 2024-01-01).
  - Totals/subtotals (these should be calculated in Power BI, not stored).

---

**6. Avoid extra rows/columns**
- Many Excel sheets start with title rows like:
  
TD SALES REPORT - Q2
 
Generated by: Eric

Date | Product | Qty | Price

  - ‚ùå Problem: Power BI may read these as data.
  - ‚úÖ Solution: Remove these extra rows, or place clean tables on a separate sheet just for import.

---

**7. Save in Compatible Formats**
- Best practice:
  - Excel: .xlsx or .xls (keep sheets tidy)
  - CSV: UTF-8 encoding, comma-separated (no semicolons or tabs unless needed)
    - Why CSVs are nice:
      - Lightweight and load fast
      - Easy to version-control (e.g., Git)
      - Compatible across platforms
     
---

**8. Use a calendar table**

### üìÖ Calendar Table Example

- Time intelligence (e.g., YTD, MOM, YOY) requires a full calendar ‚Äî not just the dates in your data.
- A calendar table should include columns like:

| Date       | Year | Month | Quarter | Week | DayName |
|------------|------|--------|---------|------|---------|
| 2025-01-01 | 2025 | Jan    | Q1      | 1    | Wed     |
| 2025-01-02 | 2025 | Jan    | Q1      | 1    | Thu     |
| 2025-01-03 | 2025 | Jan    | Q1      | 1    | Fri     |
| 2025-01-04 | 2025 | Jan    | Q1      | 1    | Sat     |
| 2025-01-05 | 2025 | Jan    | Q1      | 1    | Sun     |
| 2025-01-06 | 2025 | Jan    | Q1      | 2    | Mon     |

- You can:
  - Generate it in Excel
  - Use Power BI DAX:
    - ```Calendar = CALENDAR(DATE(2020,1,1), DATE(2030,12,31))```
    - Then relate ```Sales[Date]``` ‚Üí ```Calendar[Date]```.
   
---



**9. Avoid Formulas in Excel**

- Avoid using formulas like `=SUM(...)`, `=VLOOKUP(...)`, or `=IF(...)` in Excel ‚Äî they can be fragile or lost when importing.
- Power BI uses its own formula language called **DAX**, which is more robust and scalable.
- Example (DAX):
```DAX
TotalSales = SUM(Sales[Quantity] * Sales[Price])
```
- Best practice: Export raw data only from Excel or CSV, and do your calculations inside Power BI using DAX.

---

**10. Name Your Excel Tables (Optional but Useful)**

- In Excel:
  - Select your data ‚Üí press Ctrl + T
  - Check "My table has headers"
  - Go to the Table Design tab ‚Üí Rename it (e.g., SalesTable)
- Why this helps:
  - Power BI will recognize and list tables by name instead of "Sheet1".
  - Makes your queries more readable and manageable.
  - Easier refresh when the source file updates.

---

## Power BI DAX

**üìå 1. DAX Fundamentals**
- What is DAX?
  - Formula language used in Power BI, Power Pivot, and SSAS Tabular models. Think of it as Excel formulas plus SQL-like capabilities.
- Syntax Basics
  - **1. Columns vs. Measures**

| Feature           | Calculated Column                                       | Measure                                                  |
|------------------|----------------------------------------------------------|----------------------------------------------------------|
| Row-by-row        | ‚úÖ Yes (each row has a result)                           | ‚ùå No (calculated across rows, based on filters)         |
| Stored in model?  | ‚úÖ Yes                                                   | ‚ùå No (calculated on demand)                             |
| Use case          | - Derived values per row<br>- Used in slicers/filters   | - Aggregated KPIs (totals, averages, %s)                 |
| Example           | `Profit = Sales[Revenue] - Sales[Cost]`                 | `Total Sales = SUM(Sales[Revenue])`                      |

---

**2. Common Aggregate Functions**

- ```SUM(column)```
  - Returns the total of all values in a column (must be numeric).
  - ```DAX
      Total Sales = SUM(Sales[Amount])
    ```
- ```AVERAGE(column)```
  - Returns the arithmetic mean of values in a column.
  - ```DAX
      Average Discount = AVERAGE(Sales[Discount])
    ```
- ```COUNTROWS(table)```
  - Counts the number of rows in a table (great for counting filtered rows).
  - ```DAX
      Number of Orders = COUNTROWS(Sales)
- ```DISTINCTCOUNT(column)```
  - Returns the number of unique (distinct) values in a column.
  - ```DAX
      Unique Customers = DISTINCTCOUNT(Sales[CustomerID])
    ```
---

### 3. Logical & Arithmetic Operators

| Type          | Operator | Example                                      | Description                    |
|---------------|----------|----------------------------------------------|--------------------------------|
| Addition      | `+`      | `Sales[Price] + Sales[Tax]`                 | Adds numbers                   |
| Subtraction   | `-`      | `Sales[Price] - Sales[Discount]`            | Subtracts numbers              |
| Multiplication| `*`      | `Sales[Qty] * Sales[UnitPrice]`             | Multiplies values              |
| Division      | `/`      | `Sales[Revenue] / Sales[Units]`             | Divides values                 |
| Equality      | `=`      | `Sales[Region] = "West"`                    | True/False comparison          |
| Not equal     | `<>`     | `Sales[Category] <> "Electronics"`          | Not equal                      |
| AND           | `&&`     | `[Sales] > 1000 && [Profit] > 200`          | Both conditions must be true   |
| OR            | `||`     | `[Region] = "East" || [Region] = "West"`    | At least one must be true      |

---

### 4. Example: Combining It All

Let‚Äôs say we want to build a measure to calculate **high-value sales count** where:

- Sales amount is greater than $500  
- The region is not `"South"`

```dax
High Value Sales Count = 
CALCULATE(
    COUNTROWS(Sales),
    Sales[Amount] > 500 && Sales[Region] <> "South"
)
```

---

## Time Intelligence

- Time Intelligence is **one of the most important concepts in Power BI** ‚Äî it lets you **analyze data over time**, such as comparing sales this year to last year, calculating year-to-date totals, or creating running totals. Mastering this requires
- **a separate calendar table**, and here‚Äôs a full breakdown of what you need to know.

---

**1. üìÖ What Is Time Intelligence in Power BI?**
- Time Intelligence refers to DAX functions that help you perform calculations across dates ‚Äî like:
  - Year-to-Date (YTD), Quarter-to-Date (QTD), Month-to-Date (MTD)
  - Previous periods (e.g., previous month, previous year)
  - Rolling averages, running totals
  - Same period last year
  - Comparing growth vs. past periods

---

**2. ‚ùì Why You Need a Separate Calendar Table**
- Power BI requires a proper date table to use time intelligence functions like ```TOTALYTD```, ```SAMEPERIODLASTYEAR```, etc.
  - Here's why:
    - **Completeness**: Your fact table (like Sales) may not contain every single date, especially if there were no transactions.
    - **Relationships**: Time intelligence functions require a relationship between your fact table and a continuous date table.
    - **Filtering & Grouping**: You can group by year, month, week, quarter, etc., from one source.
    - **Consistent Logic**: You can create time-based columns like ‚ÄúFiscal Year,‚Äù ‚ÄúIsWeekend,‚Äù etc., once ‚Äî and use them across your report.

 ---

 **3. üõ†Ô∏è How to Create a Calendar Table**
 - You have two common ways:
   - **Option 1: Auto-generated in DAX**
   - ```DAX
     Calendar = CALENDAR(DATE(2024,11,1), DATE(2025,10,31))
     ```
     - This creates a new table that contains **one column only**, named ```Date``` that contains **every single day** from November 1, 2024 to October 31, 2025. It is **continous, sequential with no gaps**. The column's Data type is **Date**.
     - 2024-11-01, 2024-11-02, etc.
     - This table **does not** include:
       - **Year**, **Month**, **Quarter** columns
       - **Month Names**, **Weekdays**, or **Fiscal logic**
       - **Sorting logic** for month names (e.g., Jan, Feb... ordered alphabetically unless fixed manually). 
   - **Option 2: With additional columns**
   - ```DAX
     Calendar = 
      ADDCOLUMNS (
          CALENDAR(DATE(2020, 1, 1), DATE(2030, 12, 31)),
          "Year", YEAR([Date]),
          "Month Number", MONTH([Date]),
          "Month Name", FORMAT([Date], "MMMM"),
          "Quarter", "Q" & FORMAT([Date], "Q"),
          "Day", DAY([Date]),
          "Weekday", FORMAT([Date], "dddd"),
          "IsWeekend", IF(WEEKDAY([Date], 2) > 5, TRUE, FALSE)
      )
     ```
| Date       | Year | Month Number | Month Name | Quarter | Day | Weekday   | IsWeekend |
|------------|------|---------------|-------------|---------|-----|------------|------------|
| 2024-11-01 | 2024 | 11            | November    | Q1      | 1   | Friday     | FALSE      |
| 2024-11-02 | 2024 | 11            | November    | Q1      | 2   | Saturday   | TRUE       |
| 2024-11-03 | 2024 | 11            | November    | Q1      | 3   | Sunday     | TRUE       |
| ...        | ...  | ...           | ...         | ...     | ... | ...        | ...        |
| 2025-10-31 | 2025 | 10            | October     | Q4      | 31  | Friday     | FALSE      |
    - Once created, go to Model View and:
      - Set the column [Date] as "Date" data type
      - Mark as Date Table (very important!)
      - Create a relationship to your fact table (e.g., Sales[Date] ‚Üí Calendar[Date])

---

**4. Common Time Intelligence Calculations**
- You must use your Calendar table's [Date] column in these formulas.
- **Year-to-date (YTD)**
  - ```DAX
      Sales YTD = TOTALYTD(SUM(Sales[Amount]), 'Calendar'[Date])
    ```
- **Previous Year**
  - ```DAX
      Sales Last Year = CALCULATE(SUM(Sales[Amount]), SAMEPERIODLASTYEAR('Calendar'[Date]))
    ```
- **Month-to-date (MTD)**
  - ```DAX
      Sales MTD = TOTALMTD(SUM(Sales[Amount]), 'Calendar'[Date])
    ```
- **Rolling 12 Months**
  - ```DAX
      Rolling 12M Sales =
      CALCULATE(
        SUM(Sales[Amount]),
        DATESINPERIOD('Calendar'[Date], MAX('Calendar'[Date]), -12, MONTH)
      )
    ```
  - It calculates the sum of sales over the last 12 months, ending at the current date in context.
    
- **YoY Growth %**
  - ```DAX
      YoY Growth % =
      DIVIDE(
        [Sales YTD] - [Sales Last Year],
        [Sales Last Year]
      )
    ```

---

**5. Common Mistakes to Avoid**

| Mistake                                 | Why It's a Problem                                              |
|-----------------------------------------|------------------------------------------------------------------|
| Not using a Calendar table              | Breaks all time intelligence functions                          |
| Using the date from the fact table      | Time functions won‚Äôt work properly                              |
| Not marking your calendar as "Date Table" | Power BI can't apply DAX time logic                             |
| Date column not unique                  | Relationships won‚Äôt work                                        |
| Calendar doesn‚Äôt span full range of data | Time functions return blanks                                    |
